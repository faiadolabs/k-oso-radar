<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Radar Escalable en Km</title>
<style>
    body { margin: 0; overflow: hidden; background: #000; color: white; font-family: monospace; }
    #controls {
        position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7);
        padding: 10px; border-radius: 5px; font-size: 14px;
    }
    input { width: 80px; }
</style>
</head>
<body>

<canvas id="radar"></canvas>

<div id="controls">
    <div>
        <label>Distancia (km): <input type="number" step="0.1" id="distance" value="3.5"></label>
        <label>Rumbo: <input type="number" step="1" id="angle" value="45"></label>
        <button id="addPoint">Agregar Punto</button>
    </div>
    <div>
        <label>Escala (px/km): <input type="number" id="scaleBase" value="20" min="1" step="1"></label>
    </div>
    <div id="mouseInfo">Mouse: r=0 km, Î¸=0Â°</div>
</div>

<script>
const canvas = document.getElementById('radar');
const ctx = canvas.getContext('2d');
let width = canvas.width = window.innerWidth;
let height = canvas.height = window.innerHeight;

// ðŸ”§ Escala base: 1 km = X pÃ­xeles (ajustable)
let pixelsPerKm = parseInt(document.getElementById('scaleBase').value);

let offsetX = 0, offsetY = 0;
let scale = 1;
const minScale = 0.5, maxScale = 5;

let points = [];
let radarAngle = 0; // Ã¡ngulo del haz animado

// Polar â†’ Cartesiano
function polarToCartesian(r, angleDegrees) {
    const angle = angleDegrees * Math.PI / 180;
    const cx = width / 2;
    const cy = height / 2;
    return {
        x: cx + r * Math.sin(angle),
        y: cy - r * Math.cos(angle)
    };
}

// Cartesiano â†’ Polar
function cartesianToPolar(x, y) {
    const cx = width / 2;
    const cy = height / 2;
    const dx = x - cx;
    const dy = cy - y;
    const r = Math.sqrt(dx*dx + dy*dy) / pixelsPerKm; // convertir a km
    let theta = Math.atan2(dx, dy) * 180 / Math.PI;
    if (theta < 0) theta += 360;
    return {r, theta};
}

// Dibujar radar
function drawRadar() {
    ctx.save();
    ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
    ctx.clearRect(-offsetX/scale, -offsetY/scale, width/scale, height/scale);

    const cx = width / 2;
    const cy = height / 2;

    // Fondo
    ctx.fillStyle = 'black';
    ctx.fillRect(-offsetX/scale, -offsetY/scale, width/scale, height/scale);

    // CÃ­rculos concÃ©ntricos cada 5 km
    ctx.strokeStyle = 'rgba(0,255,0,0.3)';
    ctx.fillStyle = 'lime';
    ctx.font = "12px monospace";
    for (let rKm = 5; rKm <= 100; rKm += 5) { 
        ctx.beginPath();
        ctx.arc(cx, cy, rKm * pixelsPerKm, 0, 2*Math.PI);
        ctx.stroke();
        ctx.fillText(`${rKm} km`, cx + rKm * pixelsPerKm + 5, cy - 5);
    }

    // Punto central
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(cx, cy, 5, 0, 2*Math.PI);
    ctx.fill();

    // Puntos rojos (guardados en km)
    points.forEach(p => {
        const pos = polarToCartesian(p.rKm * pixelsPerKm, p.angle);
        ctx.fillStyle = 'red';
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 6, 0, 2*Math.PI);
        ctx.fill();
    });

    // Haz del radar
    const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, width);
    grad.addColorStop(0, "rgba(0,255,0,0.4)");
    grad.addColorStop(1, "rgba(0,255,0,0)");
    ctx.fillStyle = grad;

    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, width, (radarAngle-1)*Math.PI/180, (radarAngle+1)*Math.PI/180);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
}

// AnimaciÃ³n
function animate() {
    radarAngle = (radarAngle + 1) % 360;
    drawRadar();
    requestAnimationFrame(animate);
}

// Agregar punto (en km)
document.getElementById('addPoint').addEventListener('click', () => {
    const r = parseFloat(document.getElementById('distance').value);
    const angle = parseFloat(document.getElementById('angle').value);
    points.push({rKm: r, angle});
});

// Cambiar escala base dinÃ¡micamente
document.getElementById('scaleBase').addEventListener('input', e => {
    pixelsPerKm = parseInt(e.target.value);
});

// Zoom con rueda
canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.05;
    const mouseX = e.clientX;
    const mouseY = e.clientY;
    const prevScale = scale;

    if (e.deltaY < 0) {
        scale *= zoomFactor;
    } else {
        scale /= zoomFactor;
    }
    scale = Math.min(maxScale, Math.max(minScale, scale));

    // Mantener el mouse en el mismo lugar al hacer zoom
    offsetX = mouseX - (mouseX - offsetX) * (scale / prevScale);
    offsetY = mouseY - (mouseY - offsetY) * (scale / prevScale);
});

// Pan
let dragging = false, startX, startY;
canvas.addEventListener('mousedown', e => { dragging = true; startX = e.clientX - offsetX; startY = e.clientY - offsetY; });
canvas.addEventListener('mousemove', e => {
    if (dragging) {
        offsetX = e.clientX - startX;
        offsetY = e.clientY - startY;
    }
    // Coordenadas del mouse en km
    const invX = (e.clientX - offsetX) / scale;
    const invY = (e.clientY - offsetY) / scale;
    const polar = cartesianToPolar(invX, invY);
    document.getElementById('mouseInfo').textContent = 
        `Mouse: r=${polar.r.toFixed(1)} km, Î¸=${polar.theta.toFixed(1)}Â°`;
});
canvas.addEventListener('mouseup', () => dragging = false);
canvas.addEventListener('mouseleave', () => dragging = false);

// Redimensionar
window.addEventListener('resize', () => {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
});

// Iniciar animaciÃ³n
animate();
</script>

</body>
</html>
