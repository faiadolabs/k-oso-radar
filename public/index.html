<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Radar con Alcance Ajustable</title>
<style>
    body { margin: 0; overflow: hidden; background: #000; color: white; font-family: monospace; }
    #controls {
        position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7);
        padding: 10px; border-radius: 5px; font-size: 14px;
    }
    input { width: 80px; }
</style>
</head>
<body>

<canvas id="radar"></canvas>

<div id="controls">
    <div>
        <p>k-oso radar</p>
        <label>Distancia (km): <input type="number" step="0.1" id="distance" value="3.5"></label>
        <label>Rumbo: <input type="number" step="1" id="angle" value="45"></label>
        <div>
            Color del punto:
            <button class="colorBtn" data-color="#622263" style="background:#622263;width:15px;height:15px;border:3px;border-radius:50%;margin:2px;cursor:pointer;"></button>
            <button class="colorBtn" data-color="#455134" style="background:#455134;width:15px;height:15px;border:3px;border-radius:50%;margin:2px;cursor:pointer;"></button>
            <button class="colorBtn" data-color="#564727" style="background:#564727;width:15px;height:15px;border:3px;border-radius:50%;margin:2px;cursor:pointer;"></button>
            <button class="colorBtn" data-color="#614527" style="background:#614527;width:15px;height:15px;border:3px;border-radius:50%;margin:2px;cursor:pointer;"></button>
            <button class="colorBtn" data-color="#777777" style="background:#777777;width:15px;height:15px;border:3px;border-radius:50%;margin:2px;cursor:pointer;"></button>
            <label>Color del punto: <input type="color" id="pointColor" value="#00FF00" style="width:24px; height:24px; padding:0; border:none; vertical-align:middle;"></label>
        </div>
        <div>
            <label>Nota:</label><br>
            <textarea id="note" maxlength="255" rows="4" cols="40" 
              placeholder="Escribe una nota (máx. 255 caracteres)" 
              style="resize:none; font-family:monospace; font-size:13px; width:95%;"></textarea>
        </div>
        <button id="addToPoint">Add TO</button>
        <button id="addFromPoint">Add FROM</button>
    </div>
    <div>
        <label>Escala (px/km): <input type="number" id="scaleBase" value="20" min="1" step="1"></label>
    </div>
    <div>
        <label>Alcance (km): <input type="number" id="rangeKm" value="100" min="10" step="5"></label>
    </div>
    <div id="mouseInfo">Mouse: r=0 km, θ=0°</div>
</div>

<div id="modal" style="
  display:none;
  position:fixed; top:0; left:0; right:0; bottom:0;
  background: rgba(0,0,0,.65);
  align-items:center; justify-content:center;
  z-index:100;
">
  <div style="background:#111; padding:20px; border:1px solid #0f0; border-radius:10px; color:#0f0; min-width:220px;">
    <h3 style="margin-top:0;">Información del punto</h3>
    <p id="modalContent">---</p>
  </div>
</div>


<script>
const canvas = document.getElementById('radar');
const ctx = canvas.getContext('2d');
let width = canvas.width = window.innerWidth;
let height = canvas.height = window.innerHeight;

let pixelsPerKm = parseInt(document.getElementById('scaleBase').value);
let radarRangeKm = parseInt(document.getElementById('rangeKm').value);

let offsetX = 0, offsetY = 0;
let scale = 1;
const minScale = 0.5, maxScale = 5;

let points = [];
let radarAngle = 0; // ángulo del haz animado

// Polar → Cartesiano
function polarToCartesian(r, angleDegrees) {
    const angle = angleDegrees * Math.PI / 180;
    const cx = width / 2;
    const cy = height / 2;
    return {
        x: cx + r * Math.sin(angle),
        y: cy - r * Math.cos(angle)
    };
}

// Cartesiano → Polar
function cartesianToPolar(x, y) {
    const cx = width / 2;
    const cy = height / 2;
    const dx = x - cx;
    const dy = cy - y;
    const r = Math.sqrt(dx*dx + dy*dy) / pixelsPerKm; // convertir a km
    let theta = Math.atan2(dx, dy) * 180 / Math.PI;
    if (theta < 0) theta += 360;
    return {r, theta};
}

/**
 * Calcula el rumbo complementario/opuesto de un ángulo en grados.
 * @param {number} heading - Rumbo actual (0-360)
 * @returns {number} Rumbo complementario (0-360)
 */
 function complementaryHeading(heading) {
    if (typeof heading !== 'number' || isNaN(heading)) {
        throw new Error('El rumbo debe ser un número válido');
    }

    // Normalizamos el rumbo a 0-360
    const normalized = ((heading % 360) + 360) % 360;

    // El rumbo complementario está 180° opuesto
    const complement = (normalized + 180) % 360;

    return complement;
}

// Dibujar radar
function drawRadar() {
    ctx.save();
    ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
    ctx.clearRect(-offsetX/scale, -offsetY/scale, width/scale, height/scale);

    const cx = width / 2;
    const cy = height / 2;
    const maxRadiusPx = radarRangeKm * pixelsPerKm;

    // Fondo
    ctx.fillStyle = 'black';
    ctx.fillRect(-offsetX/scale, -offsetY/scale, width/scale, height/scale);

    // Círculos concéntricos cada 5 km hasta el alcance máximo
    ctx.strokeStyle = 'rgba(0,255,0,0.3)';
    ctx.fillStyle = 'lime';
    ctx.font = "12px monospace";
    for (let rKm = 5; rKm <= radarRangeKm; rKm += 5) { 
        ctx.beginPath();
        ctx.arc(cx, cy, rKm * pixelsPerKm, 0, 2*Math.PI);
        ctx.stroke();
        ctx.fillText(`${rKm} km`, cx + rKm * pixelsPerKm + 5, cy - 5);
    }

    // Cruz central
    ctx.strokeStyle = 'rgba(0,255,0,0.5)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(cx, cy - maxRadiusPx); ctx.lineTo(cx, cy + maxRadiusPx); // Vertical
    ctx.moveTo(cx - maxRadiusPx, cy); ctx.lineTo(cx + maxRadiusPx, cy); // Horizontal
    ctx.stroke();

    // Etiquetas cardinales (colocadas en el borde del alcance)
    ctx.fillStyle = 'white';
    ctx.font = "bold 16px monospace";
    ctx.fillText("N", cx - 5, cy - maxRadiusPx - 10);
    ctx.fillText("S", cx - 5, cy + maxRadiusPx + 20);
    ctx.fillText("E", cx + maxRadiusPx + 10, cy + 5);
    ctx.fillText("W", cx - maxRadiusPx - 25, cy + 5);

    // Punto central
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(cx, cy, 5, 0, 2*Math.PI);
    ctx.fill();

    // Puntos rojos (solo si están dentro del alcance)
    points.forEach(p => {
        if (p.rKm <= radarRangeKm) {
            const pos = polarToCartesian(p.rKm * pixelsPerKm, p.angle);
            ctx.fillStyle = p.color || '#777777'; // si no hay color, usa rojo por defecto
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 6, 0, 2*Math.PI);
            ctx.fill();
        }
    });

    // Haz del radar (recortado al alcance máximo)
    ctx.save();
    ctx.beginPath();
    ctx.arc(cx, cy, maxRadiusPx, 0, 2*Math.PI);
    ctx.clip();

    const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, maxRadiusPx);
    grad.addColorStop(0, "rgba(0,255,0,0.4)");
    grad.addColorStop(1, "rgba(0,255,0,0)");
    ctx.fillStyle = grad;

    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, maxRadiusPx, (radarAngle-1)*Math.PI/180, (radarAngle+1)*Math.PI/180);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    ctx.restore();
}

// Animación
function animate() {
    radarAngle = (radarAngle + 1) % 360;
    drawRadar();
    requestAnimationFrame(animate);
}

// Agregar punto TO (en km hacia el cluster desde el VOR)
document.getElementById('addToPoint').addEventListener('click', () => {
    // Simplemente le paso el rumbo del cajetín
    agregarPunto(parseFloat(document.getElementById('angle').value));
});

// Agregar punto FROM (en km desde el cluster hasta el VOR)
document.getElementById('addFromPoint').addEventListener('click', () => {
    agregarPunto(complementaryHeading(parseFloat(document.getElementById('angle').value)));
});

// Se agrega el punto siguiendo el águlo del radial FROM (desde el centro hasta el punto)
function agregarPunto(angle){
    const r = parseFloat(document.getElementById('distance').value);
    const note = document.getElementById('note').value.slice(0,255);
    const color = document.getElementById('pointColor').value;
    // Se pasa el radio del círculo a dibujar (importante para luego saber si se clica o no en el pq no es posible event DOM)
    points.push({rKm: r, angle, radius_circulo: 6, note, color});

    // LIMPIAR CAMPOS
    // document.getElementById('distance').value = '';
    // document.getElementById('angle').value = '';
}

// Cambiar escala base dinámicamente
document.getElementById('scaleBase').addEventListener('input', e => {
    pixelsPerKm = parseInt(e.target.value);
});

// Cambiar alcance del radar
document.getElementById('rangeKm').addEventListener('input', e => {
    radarRangeKm = parseInt(e.target.value);
});

document.querySelectorAll('.colorBtn').forEach(btn => {
    btn.addEventListener('click', () => {
        selectedColor = btn.dataset.color;
        // visualmente marcar el botón activo
        document.querySelectorAll('.colorBtn').forEach(b => b.style.outline = '');
        btn.style.outline = '2px solid white';
        // opcional: sincronizar el input color con el botón clicado
        document.getElementById('pointColor').value = selectedColor;
    });
});

canvas.addEventListener('click', e => {
    const invX = (e.clientX - offsetX) / scale;
    const invY = (e.clientY - offsetY) / scale;

    const clickedPoint = points.find(p => {
        const pos = polarToCartesian(p.rKm * pixelsPerKm, p.angle);
        const dx = invX - pos.x;
        const dy = invY - pos.y;
        return dx*dx + dy*dy <= p.radius_circulo*p.radius_circulo;
    });

    if (clickedPoint) {
        document.getElementById('modalContent').innerHTML = `
            <b>Rumbo TO:</b> ${clickedPoint.angle.toFixed(1)}°<br>
            <b>Rumbo FROM:</b> ${complementaryHeading(clickedPoint.angle).toFixed(1)}°<br>
            <b>Distancia:</b> ${clickedPoint.rKm.toFixed(1)} km<br>
            <br><b>Nota:</b><br>
             <span id="modalNote" style="white-space: pre-wrap;"></span>
        `;
        document.getElementById('modalNote').textContent = clickedPoint.note || '(sin nota)';

        modal.style.display = 'flex';
    }
});

// Para cerrar la modal cuando se hace clic fuera
const modal = document.getElementById('modal');
const modalContent = modal.querySelector('div');

// Cerrar si se hace clic en el overlay
modal.addEventListener('click', () => {
  modal.style.display = 'none';
});

// Evitar que se cierre si clicas dentro de la caja de contenido
modalContent.addEventListener('click', (e) => {
  e.stopPropagation();
});

// Zoom con rueda
canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = 1.05;
    const mouseX = e.clientX;
    const mouseY = e.clientY;
    const prevScale = scale;

    if (e.deltaY < 0) {
        scale *= zoomFactor;
    } else {
        scale /= zoomFactor;
    }
    scale = Math.min(maxScale, Math.max(minScale, scale));

    // Mantener el mouse en el mismo lugar al hacer zoom
    offsetX = mouseX - (mouseX - offsetX) * (scale / prevScale);
    offsetY = mouseY - (mouseY - offsetY) * (scale / prevScale);
});

// Pan
let dragging = false, startX, startY;
canvas.addEventListener('mousedown', e => { dragging = true; startX = e.clientX - offsetX; startY = e.clientY - offsetY; });
canvas.addEventListener('mousemove', e => {
    if (dragging) {
        offsetX = e.clientX - startX;
        offsetY = e.clientY - startY;
    }
    // Coordenadas del mouse en km
    const invX = (e.clientX - offsetX) / scale;
    const invY = (e.clientY - offsetY) / scale;
    const polar = cartesianToPolar(invX, invY);
    document.getElementById('mouseInfo').textContent = 
        `Mouse: r=${polar.r.toFixed(1)} km, θ=${polar.theta.toFixed(1)}°`;
});
canvas.addEventListener('mouseup', () => dragging = false);
canvas.addEventListener('mouseleave', () => dragging = false);

// Redimensionar
window.addEventListener('resize', () => {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
});

// Iniciar animación
animate();
</script>

</body>
</html>
